# Unity plugin for Do-It-Better SDK

## Installation

### Short
Download and open **.unitypackage** of the latest release.

### Long

If you feel a little adventurous today, do not hesitate to read through this repo. You then can just copy what you want in your project.

## Integration

We highly appreciate your feedback on any issues including (and not limited or course) documentation. Event the tighniest of typo will be happily addressed by our team. 

### Basics

After you get plugin files into your project you need to add initialization call.
```
GameBoostSDK.Initialize(APIKey);
```

It's strongly recommended to put this call as **early** as possible, i.e. right on your splash screen. Fancy that!
In fact, we make our best to make sure your game isn't affected by our library. We use background threads,
but keep their number short. We reuse TCP connections, relentlessly cache and do only what absolutely necessary.

Please do not hesitate to file an issue if your game performance is barbarously affected by this SDK.

### Logging

If you're about to ask some help, please run your game with this line on and attach the logs.
```
GameBoostSDK.SetLoggingEnabled(true);
```

### Development build

If you use #defines, flags or settings to detect development build call the following method as soon as you have detected that this flag, setting or #define is on.

```
GameBoostSDK.MarkAsDevelopment();
```

If you use development menu (e.g. 10 taps on left top corner) call this method as soon as this menu is open.

**Note:** It's safe to call it as many times as you need. It remembers the state inside and converts any subsequent calls after the first one to NoOp 


### Sandbox environment tracking

SDK is trying to determine if the app running is a development build.
I.e. a build which is run by a developer or a QA specialist.
Although this kind of detection can't be done with 100% accuracy, the SDK does its
best to achieve the result.

If you're interested in this value you can subscribe to an event
that is fired when the SDK updates the value.

```
GameBoostSDK.Events.sandboxStatus += OnSandboxStatus;
```

**Be aware**:
* Detection could involve network calls. In that case
  the event could be called at any point after the app launch.
* Detection could happen several times per application launch.
  Expect the event could be fired multiple times as well.
* Consider subscribing to event **before** calling `Initialize`. Some platforms
  fire the event during initialization.


## Purchase Tracking

SDK provides API to track revenue. SDK splits revenue into two big categories: in-app purchases and everything else. Everything else here is usually just ad clicks or views.

### In-app tracking

```
GameBoostSDK.TrackPurchase(1.99, "EUR", transactionId);
```

`transactionId` here is a unique identifier for a purchase. On **iOS** it's called Transaction ID, on **Android** it's called Order ID. Providing it helps SDK to deduplicate revenue events. It's highly recommended to provide such an ID generated by **OS**. If you **don't have** access to such an ID it's **better to omit** this parameter rather than send any custom id.

### Ad clicks tracking

```
GameBoostSDK.TrackRevenue(0.01, "BYN");
```

## Game Events

As the very first thing you need to send any game related event you need to create `IGame` object.
```
IGame game = GameBoostSDK.CreateGame(balance);
```
This object will create a key for the given balance object. It's recommended to create only one such object for the whole application launch. Balance object should contain all information about game balance. Therefore it tents to be very big (some megabytes) and creating a key for it can take too much time (hundreds of milliseconds) to call it inside normal game loop.

### Balance

`balance` is a **Data Object** the contains **all** global game design information about the game.

```
{
  "data": {
    "weaponData": {/* weapon json data */},
    "enemiesData": {/* enemies data */},
    ... etc ...
  }
}
```

There's no any requirements or restrictions to a format or structure of the data in this object. However, please concider the following recommendations:
1. Rule **number one** is: do **not** modify the data. That is, put different files, table rows, etc. in exact way as you read them. If you have some JSON file to describe your room or just a part of the room (e.g. a certain trap in the room) it's recommended to just put it to this data object **as is**
1. Be consistent in the data structures. do **not** modify, if possible, the data object for a given room if the room didn't change. **However** if you really have changed the format of files rule **number one** takes precedence.
1. Assume some spare levels in JSON tree for files format modifications. Even if you have only one JSON describing the room, it's recommended to put it in the first or second tree level, e.g:
```
{
  "files": {
    "mainXML": ... /* actual data from that XML */
  }
}
```

Later if you'll add some other file to the balance, you'll be able to
```
{
  "files": {
    "mainXML": ... /* actual data from that XML */,
    "secondXML": ... /* actual data from second XML */
  }
}
```

This approach is the opposite to:
```
# initial JSON contains just data of the first XML:
{
  "startHealth": 1000,
  "expPerLevel": 500,
  ...
}
# Then you added a second XLM:
{
  "startHealth": 1000,
  "expPerLevel": 500,
  ...
  "secondXML": ... /* actual data from second XML */
}
```
In that case it's possible to have a name clash with keys in first XML and `"secondXML"` string.

## Game Behaviour Control

After our system has acquired enough data it can suggest certain changes to the game flow as the player
plays the game. Those changes are produced on the fly, i.e. as the player plays the game the game should
as SDK for what to do next.

### Latency

Each such request involves network call. Network calls tend to be inconsistent in their latency due to number
of external reasons. To smooth game experience and ease SDK integrations all such calls are guaranteed
to return no later than 5 seconds.

### Empty response handling

In certain situations the SDK won't produce any meaningful suggestion. In that case the result of behaviour 
changing calls will be empty. You will need to check if the response is not empty prior to applying it to a game.

**IMPORTANT** Some behaviour changing calls return several pieces of information. For example, `LeveData` has
`roomName` to use as next level **and** `dynamicBalance` to use in the next level. **Both** of these parts
can be empty independently from each other. Here's a pseudo code to handle such situations:

```
var levelData = ... // some code that acquires level data from SDK
if (levelData.roomName is not empty) {
  use levelData.roomName as the next room
}

// at this point even if roomName is empty, the dynamic balance will have the chance to be applied
if (levelData.dynamicBalance) {
  use levelData.dynamicBalance as dynamic balance for the next room
}
```

Each response type has its own ways to check if the result is empty. General rule is to check all possible
bad values, i.e. `null` values, empty strings, empty arrays (or arrays of wrong size), etc.

If the response is empty in some parts the game should behave as if SDK won't there. That means,
if the `roomName` is empty the game should ask its own algorithm which room to use next.

### Response freshness

Behaviour changing calls involve network. You might want to make these calls in advance to avoid
loading times and improve user experience.

In that case it's **important** to keep such call not older than one room. SDK performance depends
heavily on the knowledge of how the player plays **this exact session**. 
For example:

* The players starts to play the room number 6 in the first location
* At this point it's reasonable to ask SDK what room to use as room 7, **but** it's strongly
discouraged to ask for room 8, 9, and so on at this point in time.
* The player finished the room number 6. Started room number 7. The game sent `RoomStarted` event for the
  room number 7.
* At this moment you can ask SDK for the `levelData` for the room number 8.

### Coroutines

Each behaviour control call has two versions: with callback and with coroutine object. Both of these versions
are completely identical. You can choose any version depending on your preferences.

## Game Behaviour Control API

### Level Data

You can ask for level data in one of the following ways:

```c#
game.Level("1_6", levelData => {
  ... // code to process levelData
});

// in a coroutine context
var request = game.LevelRequest("1_6")
yield return request.Run();
if (request.IsDone) {
  ... // code to process levelData
}
```

Once you have `LevelData` object in hand you can process its contents like this:

```c#
var levelData = ...
if (!string.IsNullOrWhiteSpace(levelData.RoomName)) {
  ChangeNextRoom(levelData.RoomName)
}
if (levelData.DynBalance != null) {
  if (levelData.DynBalance["some_dyn_balance_key"].IsString) {
    ApplySomeDynBalanceForTheNextRoom(levelData.DynBalance["some_dyn_balance_key"])
  }
  if (leveData.DynBalance["some_other_key"].IsNumber) {
    ApplySomeOtherDynBalanceForTheNextRoom(leveData.DynBalance["some_other_key"].AsInt)
  }
}
```

### Abilities Data

You can ask for abilities data in one of the following ways:

```c#
game.Abilities("1_6", "level_up", abilitiesData => {
  ... // code to process abilitiesData
});

// in a coroutine context
var request = game.AbilitiesRequest("1_6", "level_up")
yield return request.Run();
if (request.IsDone) {
  ... // code to process abilitiesData
}
```

Once you have `AbilitiesData` object in hand you can process its contents like this:

```c#
var abilitiesData = ...
if ((abilitiesData.abilities != null)
 && (abilitiesData.abilities.Count == 3/* or 2 or other number you expect */) ) {
  ApplyAbilitiesForTheNextRoom(abilitiesData.abilities)
}
```

## Game Types

We respect each game's personality. Carefully harvesting each event and putting it in the right bucket.
Different kind of Games need different treatment.

Here's the list of currently supported integrations:
* [Archero-style games](https://github.com/chestnut42/doitbetter-unity/blob/main/docs/archero-style.md)


## Data Object

Several APIs utilise concept of **Data Object**. **Data Object** is an object that contain any serializable data, including embedded **Data Objects**. In simple words it's the kind of data, that can be losslessly converted to JSON.

In **Unity** this object is a `Dictionary<string, object>`. Such as:
* **All** keys are `string`-s. That means **any** `Dictionary` on **any** level of data tree must have a `string` key type
* Supported number types are:
  * `int`, `uint`, `sbyte`, `byte`, `short`, `ushort`, `long`, `ulong`
  * `float`, `double`, `decimal`
* Any `object` that is not number and not a string will be called `ToString` and treated as a string
* Objects that implement `IList` and `IDictionary` will be treated as such collections
