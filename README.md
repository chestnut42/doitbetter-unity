# Unity plugin for Do-It-Better SDK

## Installation

### Short
Download and open **.unitypackage** of the latest release.

### Long

If you feel a little adventurous today, do not hesitate to read through this repo. You then can just copy what you want in your project.

## Integration

We highly appreciate your feedback on any issues including (and not limited or course) documentation. Event the tighniest of typo will be happily addressed by our team. 

### Basics

After you get plugin files into your project you need to add initialization call.
```
GameBoostSDK.Initialize(APIKey);
```

It's strongly recommended to put this call as **early** as possible, i.e. right on your splash screen. Fancy that!
In fact, we make our best to make sure your game isn't affected by our library. We use background threads,
but keep their number short. We reuse TCP connections, relentlessly cache and do only what absolutely necessary.

Please do not hesitate to file an issue if your game performance is barbarously affected by this SDK.

### Logging

If you're about to ask some help, please run your game with this line on and attach the logs.
```
GameBoostSDK.SetLoggingEnabled(true);
```

### Purchase Tracking

SDK provides API to track revenue. SDK splits revenue into two big categories: in-app purchases and everything else. Everything else here is usually just ad clicks or views.

#### In-app tracking

```
GameBoostSDK.TrackPurchase(1.99, "EUR", transactionId);
```

`transactionId` here is a unique identifier for a purchase. On **iOS** it's called Transaction ID, on **Android** it's called Order ID. Providing it helps SDK to deduplicate revenue events. It's highly recommended to provide such an ID generated by **OS**. If you **don't have** access to such an ID it's **better to omit** this parameter rather than send any custom id.

#### Ad clicks tracking

```
GameBoostSDK.TrackRevenue(0.01, "BYN");
```

### Game Events

As the very first thing you need to send any game related event you need to create `IGame` object.
```
IGame game = GameBoostSDK.CreateGame(balance);
```
This object will create a key for the given balance object. It's recommended to create only one such object for the whole application launch. Balance object should contain all information about game balance. Therefore it tents to be very big (some megabytes) and creating a key for it can take too much time (hundreds of milliseconds) to call it inside normal game loop.

#### Balance

`balance` is a **Data Object** the contains **all** global game design information about the game.

```
{
  "data": {
    "weaponData": {/* weapon json data */},
    "enemiesData": {/* enemies data */},
    ... etc ...
  }
}
```

There's no any requirements or restrictions to a format or structure of the data in this object. However, please concider the following recommendations:
1. Rule **number one** is: do **not** modify the data. That is, put different files, table rows, etc. in exact way as you read them. If you have some JSON file to describe your room or just a part of the room (e.g. a certain trap in the room) it's recommended to just put it to this data object **as is**
1. Be consistent in the data structures. do **not** modify, if possible, the data object for a given room if the room didn't change. **However** if you really have changed the format of files rule **number one** takes precedence.
1. Assume some spare levels in JSON tree for files format modifications. Even if you have only one JSON describing the room, it's recommended to put it in the first or second tree level, e.g:
```
{
  "files": {
    "mainXML": ... /* actual data from that XML */
  }
}
```

Later if you'll add some other file to the balance, you'll be able to
```
{
  "files": {
    "mainXML": ... /* actual data from that XML */,
    "secondXML": ... /* actual data from second XML */
  }
}
```

This approach is the opposite to:
```
# initial JSON contains just data of the first XML:
{
  "startHealth": 1000,
  "expPerLevel": 500,
  ...
}
# Then you added a second XLM:
{
  "startHealth": 1000,
  "expPerLevel": 500,
  ...
  "secondXML": ... /* actual data from second XML */
}
```
In that case it's possible to have a name clash with keys in first XML and `"secondXML"` string. 

### Game Types

We respect each game's personality. Carefully harvesting each event and putting it in the right bucket.
Different kind of Games need different treatment.

Here's the list of currently supported integrations:
* [Archero-style games](https://github.com/chestnut42/doitbetter-unity/blob/main/docs/archero-style.md)


### Data Object

Several APIs utilise concept of **Data Object**. **Data Object** is an object that contain any serializable data, including embedded **Data Objects**. In simple words it's the kind of data, that can be losslessly converted to JSON.

In **Unity** this object is a `Dictionary<string, object>`. Such as:
* **All** keys are `string`-s. That means **any** `Dictionary` on **any** level of data tree must have a `string` key type
* Supported number types are:
  * `int`, `uint`, `sbyte`, `byte`, `short`, `ushort`, `long`, `ulong`
  * `float`, `double`, `decimal`
* Any `object` that is not number and not a string will be called `ToString` and treated as a string
* Objects that implement `IList` and `IDictionary` will be treated as such collections
